(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{587:function(t,v,_){"use strict";_.r(v);var e=_(26),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("ul",[_("li",[_("a",{attrs:{href:"http://c.biancheng.net/socket/",target:"_blank",rel:"noopener noreferrer"}},[t._v("socket 编程入门：1 天玩转 socket 通信技术（非常详细）"),_("OutboundLink")],1)])]),t._v(" "),_("h2",{attrs:{id:"网络应用的体系结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络应用的体系结构"}},[t._v("#")]),t._v(" 网络应用的体系结构")]),t._v(" "),_("p",[t._v("网络应用的体系结构（网络应用模型）分为三种")]),t._v(" "),_("ul",[_("li",[t._v("客户/服务器模式（C/S:client/server）")]),t._v(" "),_("li",[t._v("对等模式(P2P:Peer To Peer)")]),t._v(" "),_("li",[t._v("混合体（Hybrid）：客户-服务器和对等体系结构")])]),t._v(" "),_("h3",{attrs:{id:"客户-服务器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#客户-服务器模式"}},[t._v("#")]),t._v(" 客户/服务器模式")]),t._v(" "),_("p",[t._v("在客户/服务器（Client/Server，C/S）模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求。其工作流程如下 ∶")]),t._v(" "),_("ol",[_("li",[t._v("服务器处于接收请求的状态。")]),t._v(" "),_("li",[t._v("客户机发出服务请求，并等待接收结果。")]),t._v(" "),_("li",[t._v("服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。")])]),t._v(" "),_("p",[t._v("客户程序必须知道服务器程序的地址，客户机上一般不需要特殊的硬件和复杂的操作系统。而服务器上运行的软件则是专门用来提供某种服务的程序，可同时处理多个远程或本地客户的要求。系统启动后即自动调用并一直不断地运行着，被动地等待并接收来自各地客户的请求。因此，服务器程序不需要知道客户程序的地址。客户/服务器模型最主要的特征是 ∶ 客户是服务请求方，服务器是服务提供方。如 Web 应用程序，其中总是打开的 Web 服务器服务于运行在客户机上的浏览器的请求。当 Web 服务器接收到来自客户机对某对象的请求时，它向该客户机发送所请求的对象以做出响应。常见的使用客户/服务器模型的应用包括 Web、文件传输协议（FTP）、远程登录和电子邮件等。")]),t._v(" "),_("p",[t._v("客户/服务器模型的主要特点还有:")]),t._v(" "),_("ol",[_("li",[t._v("网络中各计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的目的，使它们不能随意存储/删除数据，或进行其他受限的网络活动。整个网络的管理工作由少数服务器担当，因此网络的管理非常集中和方便。")]),t._v(" "),_("li",[t._v("客户机相互之间不直接通信。例如，在 Web 应用中两个浏览器并不直接通信。")]),t._v(" "),_("li",[t._v("可扩展性不佳。受服务器硬件和网络带宽的限制，服务器支持的客户机数有限。")])]),t._v(" "),_("h3",{attrs:{id:"p2p-模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#p2p-模式"}},[t._v("#")]),t._v(" P2P 模式")]),t._v(" "),_("p",[t._v("在 CS 模型中，服务器性能的好坏决定了整个系统的性能，当大量用户请求服务时，服务器就必然成为系统的瓶颈。P2P 模型的思想是整个网络中的传输内容不再被保存在中心服务器上，每个结点都同时具有下载、上传的功能，其权利和义务都是大体对等的。")]),t._v(" "),_("p",[t._v("在 P2P 模型中，各计算机没有固定的客户和服务器划分。相反，任意一对计算机——称为对等方（Peer），直接相互通信。实际上，P2P 模型从本质上来看仍然使用客户/服务器方式，每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。当前比较流行的 P2P 应用有 PPlive、Bittorent 和电驴等。")]),t._v(" "),_("p",[t._v("与 C/S 模型相比，P2P 模型的优点主要体现如下 ∶")]),t._v(" "),_("ol",[_("li",[t._v("减轻了服务器的计算压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结点上，因此大大提高了系统效率和资源利用率（例如，播放流媒体时对服务器的压力过大，而通过 P2P 模型，可以利用大量的客户机来提供服务）。")]),t._v(" "),_("li",[t._v("多个客户机之间可以直接共享文档。")]),t._v(" "),_("li",[t._v("可扩展性好，传统服务器有响应和带宽的限制，因此只能接受一定数量的请求。")]),t._v(" "),_("li",[t._v("网络健壮性强，单个结点的失效不会影响其他部分的结点。")])]),t._v(" "),_("p",[t._v("P2P 模型也有缺点。在获取服务的同时，还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。例如，经常进行 P2P 下载还会对硬盘造成较大的损伤。据某互联网调研机构统计，当前 P2P 程序已占互联网 50%～ 90%的流量，使网络变得非常拥塞，因此各大 ISP（互联网服务提供商，如电信、网通等）通常都对 P2P 应用持反对态度。")]),t._v(" "),_("h3",{attrs:{id:"混合模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#混合模式"}},[t._v("#")]),t._v(" 混合模式")]),t._v(" "),_("p",[_("strong",[t._v("Napster")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("文件搜索：使用 C/S 模式（集中式）")]),t._v(" "),_("ul",[_("li",[t._v("主机在中心服务器上注册其资源")]),t._v(" "),_("li",[t._v("主机向中心服务器提交查询请求，查找感兴趣的内容")])])]),t._v(" "),_("li",[_("p",[t._v("文件传输：使用 P2P 模式，任意 Peer 节点之间即时通信")])])]),t._v(" "),_("h2",{attrs:{id:"网络应用进程通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络应用进程通信"}},[t._v("#")]),t._v(" 网络应用进程通信")]),t._v(" "),_("h3",{attrs:{id:"网络应用的基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络应用的基础"}},[t._v("#")]),t._v(" 网络应用的基础")]),t._v(" "),_("p",[t._v("网络应用的基础：进程间通信")]),t._v(" "),_("p",[t._v("进程：在主机上运行的程序")]),t._v(" "),_("h3",{attrs:{id:"同一主机上运行的进程之间如何通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同一主机上运行的进程之间如何通信"}},[t._v("#")]),t._v(" 同一主机上运行的进程之间如何通信")]),t._v(" "),_("p",[t._v("在同一个主机内，使用进程间通信机制通信（操作系统定义）")]),t._v(" "),_("h3",{attrs:{id:"不同主机上运行的进程间如何通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不同主机上运行的进程间如何通信"}},[t._v("#")]),t._v(" 不同主机上运行的进程间如何通信")]),t._v(" "),_("p",[t._v("不同主机，通过交换报文（Message）来通信")]),t._v(" "),_("p",[t._v("使用 OS 提供的通信服务，按照应用协议交换报文（借助传输层提供的服务）")]),t._v(" "),_("p",[t._v("注意：P2P 架构的应用也有客户端进程和服务器进程之分，比如说， 有三个主机 A、B、C。 A 和 B 建立一个会话，A 向 B 请求资源，A 这时是客户端， B 这时是服务器；B 和 C 之间建立一个会话， B 向 C 请求资源，B 这时就是客户端，C 这时就是服务器。")]),t._v(" "),_("ul",[_("li",[t._v("客户端进程：发起通信的进程")]),t._v(" "),_("li",[t._v("服务器进程：等待连接的进程")])]),t._v(" "),_("h3",{attrs:{id:"分布式进程通信需要解决的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式进程通信需要解决的问题"}},[t._v("#")]),t._v(" 分布式进程通信需要解决的问题")]),t._v(" "),_("p",[_("strong",[_("a",{attrs:{href:"#Process_identification_addressing_issues"}},[t._v("1. 进程标识和寻址问题")])])]),t._v(" "),_("p",[_("strong",[_("a",{attrs:{href:"#tran_pro_serv_to_app"}},[t._v("2. 传输层如何向应用层提供服务")])])]),t._v(" "),_("ul",[_("li",[t._v("位置：层间界面的 SAP （TCP/IP ：socket）")]),t._v(" "),_("li",[t._v("形式：应用程序接口 API （TCP/IP ：socket API）")])]),t._v(" "),_("p",[_("strong",[t._v("3. 如何使用传输层提供的服务，实现应用进程之间的报文交换")])]),t._v(" "),_("ul",[_("li",[t._v("定义应用层协议：报文格式，解释，时序等")]),t._v(" "),_("li",[t._v("编制程序，使用 OS 提供的 API ，调用网络基础设施提供通信服务传报文，实现应用时序等；")])]),t._v(" "),_("h2",{attrs:{id:"进程标识和寻址问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程标识和寻址问题"}},[t._v("#")]),t._v(" 进程标识和寻址问题")]),t._v(" "),_("div",{attrs:{id:"Process_identification_addressing_issues"}}),t._v(" "),_("p",[t._v("不同主机上的进程进行通信，每个进程必须有"),_("strong",[t._v("标识符")]),t._v("，即 SAP")]),t._v(" "),_("p",[_("strong",[t._v("1. 如何寻址主机")])]),t._v(" "),_("p",[t._v("主机有 IP 地址（可以唯一标识 Internet 上的一台主机），仅仅有 IP 地址不能够唯一标识一个进程，在一台端系统上有很多应用进程在运行")]),t._v(" "),_("p",[_("strong",[t._v("2. 端口号（Port Numbers）")])]),t._v(" "),_("p",[t._v("有了 IP 地址，虽然可以找到目标计算机， 但是进程是跑在 TCP 还是 UDP 上的， TCP or UDP 上可能跑了很多进程。具体是哪一个？")]),t._v(" "),_("p",[t._v("有了 IP 地址，虽然可以找到目标计算机，但仍然不能进行通信。一台计算机可以同时提供多种网络服务，例如 Web 服务（网站）、FTP 服务（文件传输服务）、SMTP 服务（邮箱服务）等，仅有 IP 地址和 MAC 地址，计算机虽然可以正确接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。")]),t._v(" "),_("p",[t._v("为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web 服务的端口号是 80，FTP 服务的端口号是 21，SMTP 服务的端口号是 25")]),t._v(" "),_("p",[t._v("一个进程：用 IP + port 标识端节点，本质上，一对主机进程之间的通信由 2 个端节点构成")]),t._v(" "),_("p",[t._v("标识（寻址）一个进程最起码包括三个要素：")]),t._v(" "),_("ul",[_("li",[t._v("主机 IP")]),t._v(" "),_("li",[t._v("TCP or UDP")]),t._v(" "),_("li",[t._v("Port")])]),t._v(" "),_("h3",{attrs:{id:"can-tcp-and-udp-use-the-same-port-on-same-server"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#can-tcp-and-udp-use-the-same-port-on-same-server"}},[t._v("#")]),t._v(" Can tcp and udp use the same port on same server?")]),t._v(" "),_("p",[t._v("Yes, you can use the same port number for both TCP and UDP. Many protocols already do this, for example DNS works on udp/53 and tcp/53.")]),t._v(" "),_("p",[t._v("Technically the port pools for each protocol are completely independent, but for higher level protocols that can use either TCP or UDP it's convention that they default to the same port number.")]),t._v(" "),_("p",[t._v("When writing your server, bear in mind that the sequence of events for a TCP socket is much harder than for a UDP socket, since as well as the normal socket and bind calls you also have to listen and accept.")]),t._v(" "),_("p",[t._v("Furthermore that accept call will return a new socket and it's that socket that you'll then have to also poll for receive events. Your server should be prepared to continue accepting connections on the original socket whilst simultaneously servicing multiple clients each of which will be triggering receive events on their own sockets.")]),t._v(" "),_("ol",[_("li",[t._v("端口不是物理概念，仅仅是协议栈中的两个字节")]),t._v(" "),_("li",[t._v("TCP 和 UDP 的端口完全没有任何关系，完全有可能又有一种 XXP 基于 IP，也有端口的概念，这是完全可能的。是不同的标识空间。")]),t._v(" "),_("li",[t._v("TCP 和 UDP 传输协议监听同一个端口后，接收数据互不影响，不冲突。因为数据接收时时根据五元组（传输协议，源 IP，目的 IP，源端口，目的端口）判断接受者的。")])]),t._v(" "),_("h2",{attrs:{id:"传输层如何向应用层提供服务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输层如何向应用层提供服务"}},[t._v("#")]),t._v(" 传输层如何向应用层提供服务")]),t._v(" "),_("div",{attrs:{id:"tran_pro_serv_to_app"}}),t._v(" "),_("h3",{attrs:{id:"传输层提供的服务-需要穿过层间的信息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输层提供的服务-需要穿过层间的信息"}},[t._v("#")]),t._v(" 传输层提供的服务-需要穿过层间的信息")]),t._v(" "),_("p",[t._v("层间接口必须要携带的信息")]),t._v(" "),_("ul",[_("li",[t._v("要传输的报文（对于本层来说：SDU）")]),t._v(" "),_("li",[t._v("谁传的：我方的应用进程的标识：IP+TCP(UDP) 端口")]),t._v(" "),_("li",[t._v("传给谁：对方的应用进程的标识：对方的 IP+TCP(UDP)端口号")])]),t._v(" "),_("p",[t._v("传输层实体（tcp 或者 udp 实体）根据这些信息进行 TCP 报文段（UDP 数据报）的封装")]),t._v(" "),_("ul",[_("li",[t._v("源端口号，目标端口号，数据等")]),t._v(" "),_("li",[t._v("将 IP 地址往下交 IP 实体，用于封装 IP 数据报：源 IP,目标 IP")])]),t._v(" "),_("h3",{attrs:{id:"传输层提供的服务-层间信息的代表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输层提供的服务-层间信息的代表"}},[t._v("#")]),t._v(" 传输层提供的服务-层间信息的代表")]),t._v(" "),_("p",[t._v("如果 Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理")]),t._v(" "),_("p",[t._v("用个代号标识通信的双方或者单方：socket, 就像 OS 打开文件返回的句柄一样, 对句柄的操作，就是对文件的操作")]),t._v(" "),_("p",[_("strong",[t._v("1. TCP socket")])]),t._v(" "),_("p",[t._v("TCP socket：TCP 服务，两个进程之间的通信需要之前要建立连接，两个进程通信会持续一段时间，通信关系稳定，可以用一个整数表示两个应用实体之间的通信关系，建立连接之后会返回一个整数，就是 socket， 这个整数代表了 4 元组（双方的 IP 和端口号），是一个本地的标识，目标主机是不知道的。当然源主机网络层一下也是不知道的，只有应用层和传输层知道。")]),t._v(" "),_("p",[t._v("如果是 UDP， 这个整数就代表 2 元组（源主机的 IP 和端口号）")]),t._v(" "),_("p",[t._v("这样穿过层间接口的信息量最小")]),t._v(" "),_("p",[t._v("TCP socket：源 IP,源端口，目标 IP，目标端口"),_("br"),t._v("\nUDP socket：源 IP,源端口")]),t._v(" "),_("p",[t._v("对于使用面向连接服务（TCP）的应用而言，套接字是 4 元组的一个具有本地意义的标示")]),t._v(" "),_("ul",[_("li",[t._v("4 元组：(源 IP，源 port，目标 IP，目标 port)")]),t._v(" "),_("li",[t._v("唯一的指定了一个会话（2 个进程之间的会话关系）")]),t._v(" "),_("li",[t._v("应用使用这个标示，与远程的应用进程通信")]),t._v(" "),_("li",[t._v("不必在每一个报文的发送都要指定这 4 元组")]),t._v(" "),_("li",[t._v("就像使用操作系统打开一个文件，OS 返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名")]),t._v(" "),_("li",[t._v("简单，便于管理")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("Socket")]),t._v(" "),_("th",[t._v("源 IP")]),t._v(" "),_("th",[t._v("源 port")]),t._v(" "),_("th",[t._v("目标 IP")]),t._v(" "),_("th",[t._v("目标 port")]),t._v(" "),_("th",[t._v("状态")])])]),t._v(" "),_("tbody",[_("tr",[_("td"),t._v(" "),_("td"),t._v(" "),_("td"),t._v(" "),_("td"),t._v(" "),_("td"),t._v(" "),_("td")])])]),t._v(" "),_("p",[_("strong",[t._v("2. UDP socket")])]),t._v(" "),_("p",[t._v("UDP socket：UDP 服务，两个进程之间的通信需要之前无需建立连接， 不代表一个会话关系")]),t._v(" "),_("p",[t._v("每个报文都是独立传输的，前后报文可能给不同的分布式进程，因此，只能用一个整数表示本应用实体的标识，因为这个报文可能传给另外一个分布式进程")]),t._v(" "),_("p",[t._v("穿过层间接口的信息大小最小"),_("br"),t._v("\nUDP socket：本 IP,本端口，但是传输报文时：必须要提供对方 IP，port，接收报文时： 传输层需要上传对方的 IP，port")]),t._v(" "),_("p",[t._v("对于使用无连接服务（UDP）的应用而言，套接字是 2 元组的一个具有本地意义的标识")]),t._v(" "),_("p",[t._v("2 元组：IP，port （源端指定）")]),t._v(" "),_("p",[t._v("UDP 套接字指定了应用所在的一个端节点（end point），在发送数据报时，采用创建好的本地套接字（标识 ID），就不必在发送每个报文中指明自己所采用的 ip 和 port，但是在发送报文时，必须要指定对方的 ip 和 udp port(另外一个段节点)")]),t._v(" "),_("h2",{attrs:{id:"socket"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#socket"}},[t._v("#")]),t._v(" Socket")]),t._v(" "),_("p",[t._v("进程间通信利用 socket 发送/接收消息实现（"),_("strong",[t._v("操作系统已经提供了 socket")]),t._v("）")]),t._v(" "),_("p",[t._v("类似于寄信")]),t._v(" "),_("ul",[_("li",[t._v("发送方将消息送到门外邮箱")]),t._v(" "),_("li",[t._v("发送方依赖（门外的）传输基础设施将消息传到接收方所在主机，并送到接收方的门外")]),t._v(" "),_("li",[t._v("接收方从门外获取消息")])]),t._v(" "),_("h3",{attrs:{id:"什么是-socket"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-socket"}},[t._v("#")]),t._v(" 什么是 socket")]),t._v(" "),_("p",[t._v("socket 的原意是“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。")]),t._v(" "),_("p",[t._v("我们把插头插到插座上就能从电网获得电力供应，同样，为了与远程计算机进行数据传输，需要连接到因特网，而 socket 就是用来连接到因特网的工具。")]),t._v(" "),_("p",[t._v("socket 的典型应用就是 Web 服务器和浏览器：浏览器获取用户输入的 URL，向服务器发起请求，服务器分析接收到的 URL，将对应的网页内容返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。")]),t._v(" "),_("p",[t._v("学习 socket，也就是学习计算机之间如何通信，并编写出实用的程序。")]),t._v(" "),_("h3",{attrs:{id:"unix-linux-中的-socket-是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#unix-linux-中的-socket-是什么"}},[t._v("#")]),t._v(" UNIX/Linux 中的 socket 是什么")]),t._v(" "),_("p",[t._v("在 UNIX/Linux 系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。")]),t._v(" "),_("p",[t._v("你也许听很多高手说过，UNIX/Linux 中的一切都是文件！那个家伙说的没错。")]),t._v(" "),_("p",[t._v("为了表示和区分已经打开的文件，UNIX/Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。例如：")]),t._v(" "),_("ul",[_("li",[t._v("通常用 0 来表示标准输入文件（stdin），它对应的硬件设备就是键盘；")]),t._v(" "),_("li",[t._v("通常用 1 来表示标准输出文件（stdout），它对应的硬件设备就是显示器。")])]),t._v(" "),_("p",[t._v("UNIX/Linux 程序在执行任何形式的 I/O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。")]),t._v(" "),_("p",[t._v("请注意，网络连接也是一个文件，它也有文件描述符！你必须理解这句话。")]),t._v(" "),_("p",[t._v("我们可以通过 socket() 函数来创建一个网络连接，或者说打开一个网络文件，socket() 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：")]),t._v(" "),_("ul",[_("li",[t._v("用 read() 读取从远程计算机传来的数据；")]),t._v(" "),_("li",[t._v("用 write() 向远程计算机写入数据。")])]),t._v(" "),_("p",[t._v("你看，只要用 socket() 创建了连接，剩下的就是文件操作了，网络编程原来就是如此简单！")]),t._v(" "),_("h3",{attrs:{id:"window-系统中的-socket-是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#window-系统中的-socket-是什么"}},[t._v("#")]),t._v(" Window 系统中的 socket 是什么")]),t._v(" "),_("p",[t._v("Windows 也有类似“文件描述符”的概念，但通常被称为“文件句柄”。")]),t._v(" "),_("p",[t._v("与 UNIX/Linux 不同的是，Windows 会区分 socket 和文件，Windows 就把 socket 当做一个网络连接来对待，因此需要调用专门针对 socket 而设计的数据传输函数，针对普通文件的输入输出函数就无效了")])])}),[],!1,null,null,null);v.default=s.exports}}]);